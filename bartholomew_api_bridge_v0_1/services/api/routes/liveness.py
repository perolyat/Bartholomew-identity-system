"""
Liveness API routes for scheduler activity.

Exposes ticks, nudges, and reflections generated by the autonomy loop.
"""

from fastapi import APIRouter, HTTPException
from typing import Dict, Any
import json

from .. import db_ctx
from ..db import DB_PATH

router = APIRouter(prefix="/api/liveness", tags=["liveness"])


@router.get("/ticks")
def get_ticks(
    limit: int = 50,
    offset: int = 0
) -> Dict[str, Any]:
    """
    Get recent tick records from scheduler.
    
    Returns paginated list of drive execution records.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")
    
    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 3000")
        
        # Get total count
        cur = conn.execute("SELECT COUNT(*) FROM ticks")
        total = int(cur.fetchone()[0])
        
        # Get paginated results
        cur = conn.execute(
            """SELECT id, task_id, started_ts, finished_ts, success,
                      idempotency_key, result_meta
               FROM ticks
               ORDER BY started_ts DESC
               LIMIT ? OFFSET ?""",
            (limit, offset)
        )
        
        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "task_id": row[1],
                "started_ts": row[2],
                "finished_ts": row[3],
                "success": row[4],
                "idempotency_key": row[5],
                "result_meta": json.loads(row[6]) if row[6] else None
            }
            items.append(item)
        
        next_offset = offset + limit if offset + limit < total else None
        
        return {
            "items": items,
            "total": total,
            "next_offset": next_offset
        }


@router.get("/nudges")
def get_nudges(
    limit: int = 50,
    offset: int = 0
) -> Dict[str, Any]:
    """
    Get recent nudges from scheduler.
    
    Returns paginated list of nudges generated by drives.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")
    
    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 3000")
        
        # Get total count
        cur = conn.execute("SELECT COUNT(*) FROM nudges")
        total = int(cur.fetchone()[0])
        
        # Get paginated results, prefer created_ts_s if available
        cur = conn.execute(
            """SELECT id, kind, message, actions, reason, status,
                      COALESCE(created_ts_s, 0) as ts_sort,
                      created_ts
               FROM nudges
               ORDER BY ts_sort DESC, id DESC
               LIMIT ? OFFSET ?""",
            (limit, offset)
        )
        
        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "kind": row[1],
                "message": row[2],
                "actions": json.loads(row[3]) if row[3] else [],
                "reason": row[4],
                "status": row[5],
                "created_ts": row[6],
                "created_ts_s": row[6] if row[6] else None
            }
            items.append(item)
        
        next_offset = offset + limit if offset + limit < total else None
        
        return {
            "items": items,
            "total": total,
            "next_offset": next_offset
        }


@router.get("/reflections")
def get_reflections(
    limit: int = 50,
    offset: int = 0
) -> Dict[str, Any]:
    """
    Get recent reflections from scheduler.
    
    Returns paginated list of reflections generated by drives.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")
    
    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 3000")
        
        # Get total count
        cur = conn.execute("SELECT COUNT(*) FROM reflections")
        total = int(cur.fetchone()[0])
        
        # Get paginated results, prefer ts_s if available
        cur = conn.execute(
            """SELECT id, kind, content, meta, pinned,
                      COALESCE(ts_s, 0) as ts_sort,
                      ts
               FROM reflections
               ORDER BY ts_sort DESC, id DESC
               LIMIT ? OFFSET ?""",
            (limit, offset)
        )
        
        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "kind": row[1],
                "content": row[2],
                "meta": json.loads(row[3]) if row[3] else None,
                "pinned": bool(row[4]),
                "ts": row[6],
                "ts_s": row[5] if row[5] else None
            }
            items.append(item)
        
        next_offset = offset + limit if offset + limit < total else None
        
        return {
            "items": items,
            "total": total,
            "next_offset": next_offset
        }
