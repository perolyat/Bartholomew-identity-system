"""
Liveness API routes for scheduler activity.

Exposes ticks, nudges, and reflections generated by the autonomy loop.
"""

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import Dict, Any, List
import json
import time as _time
import datetime as dt

from .. import db_ctx
from ..db import DB_PATH

router = APIRouter(prefix="/api/liveness", tags=["liveness"])


class SelfReport(BaseModel):
    uptime: int                # seconds since process start
    drives: List[str]          # current/last drive set
    last_tick: str             # ISO8601 Zulu (e.g., 2025-10-31T04:32:00Z)


def _now_z_iso() -> str:
    return dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


@router.get("/self", response_model=SelfReport, summary="Quick self-test snapshot")
def self_report(request: Request) -> SelfReport:
    state = request.app.state
    start = getattr(state, "start_monotonic", None)
    uptime = int(max(0, _time.monotonic() - start)) if start else 0
    drives = list(getattr(state, "drives", ["self_check", "curiosity_probe", "reflection_micro"]))
    last_tick = getattr(state, "last_tick_iso", _now_z_iso())
    return SelfReport(uptime=uptime, drives=drives, last_tick=last_tick)


@router.get("/ticks")
def get_ticks(
    limit: int = 50,
    offset: int = 0
) -> List[Dict[str, Any]]:
    """
    Get recent tick records from scheduler.
    
    Returns list of drive execution records.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")
    
    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 3000")
        
        # Get results
        cur = conn.execute(
            """SELECT id, task_id, started_ts, finished_ts, success,
                      idempotency_key, result_meta
               FROM ticks
               ORDER BY started_ts DESC
               LIMIT ? OFFSET ?""",
            (limit, offset)
        )
        
        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "task_id": row[1],
                "drive_id": row[1],  # alias for tests expecting drive_id
                "started_ts": row[2],
                "finished_ts": row[3],
                "success": row[4],
                "idempotency_key": row[5],
                "result_meta": json.loads(row[6]) if row[6] else None
            }
            items.append(item)
        
        return items


@router.get("/nudges")
def get_nudges(
    limit: int = 50,
    offset: int = 0
) -> List[Dict[str, Any]]:
    """
    Get recent nudges from scheduler.
    
    Returns list of nudges generated by drives.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")
    
    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 3000")
        
        # Get results, prefer created_ts_s if available
        cur = conn.execute(
            """SELECT id, kind, message, actions, reason, status,
                      COALESCE(created_ts_s, 0) as ts_sort,
                      created_ts
               FROM nudges
               ORDER BY ts_sort DESC, id DESC
               LIMIT ? OFFSET ?""",
            (limit, offset)
        )
        
        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "kind": row[1],
                "message": row[2],
                "actions": json.loads(row[3]) if row[3] else [],
                "reason": row[4],
                "status": row[5],
                "created_ts": row[7],  # legacy ISO column
                "created_ts_s": row[6] if row[6] else None
            }
            items.append(item)
        
        return items


@router.get("/reflections")
def get_reflections(
    limit: int = 50,
    offset: int = 0
) -> List[Dict[str, Any]]:
    """
    Get recent reflections from scheduler.
    
    Returns list of reflections generated by drives.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")
    
    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 3000")
        
        # Get results, prefer ts_s if available
        cur = conn.execute(
            """SELECT id, kind, content, meta, pinned,
                      COALESCE(ts_s, 0) as ts_sort,
                      ts
               FROM reflections
               ORDER BY ts_sort DESC, id DESC
               LIMIT ? OFFSET ?""",
            (limit, offset)
        )
        
        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "kind": row[1],
                "content": row[2],
                "meta": json.loads(row[3]) if row[3] else None,
                "pinned": bool(row[4]),
                "ts": row[6],  # legacy ISO column
                "ts_s": row[5] if row[5] else None
            }
            items.append(item)
        
        return items
