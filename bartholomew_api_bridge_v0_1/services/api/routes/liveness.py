"""
Liveness API routes for scheduler activity.

Exposes ticks, nudges, and reflections generated by the autonomy loop.
"""

import datetime as dt
import json
import time as _time
from typing import Any

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel

from .. import db_ctx
from ..db import DB_PATH


router = APIRouter(prefix="/api/liveness", tags=["liveness"])


class SelfReport(BaseModel):
    uptime: int  # seconds since process start
    drives: list[str]  # current/last drive set
    last_tick: str  # ISO8601 Zulu (e.g., 2025-10-31T04:32:00Z)


def _now_z_iso() -> str:
    return (
        dt.datetime.now(dt.timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")
    )


@router.get("/self", response_model=SelfReport, summary="Quick self-test snapshot")
def self_report(request: Request) -> SelfReport:
    state = request.app.state
    start = getattr(state, "start_monotonic", None)
    uptime = int(max(0, _time.monotonic() - start)) if start else 0
    drives = list(getattr(state, "drives", ["self_check", "curiosity_probe", "reflection_micro"]))
    last_tick = getattr(state, "last_tick_iso", _now_z_iso())
    return SelfReport(uptime=uptime, drives=drives, last_tick=last_tick)


@router.get("/ticks")
def get_ticks(limit: int = 50, offset: int = 0) -> list[dict[str, Any]]:
    """
    Get recent tick records from scheduler.

    Returns list of drive execution records.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")

    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 5000")

        # Get results
        cur = conn.execute(
            """SELECT id, task_id, started_ts, finished_ts, success,
                      idempotency_key, result_meta
               FROM ticks
               ORDER BY started_ts DESC
               LIMIT ? OFFSET ?""",
            (limit, offset),
        )

        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "task_id": row[1],
                "drive_id": row[1],  # alias for tests expecting drive_id
                "started_ts": row[2],
                "finished_ts": row[3],
                "success": row[4],
                "idempotency_key": row[5],
                "result_meta": json.loads(row[6]) if row[6] else None,
            }
            items.append(item)

        return items


@router.get("/nudges")
def get_nudges(limit: int = 50, offset: int = 0) -> list[dict[str, Any]]:
    """
    Get recent nudges from scheduler.

    Returns list of nudges generated by drives.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")

    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 5000")

        # Get results, prefer created_ts_s if available
        cur = conn.execute(
            """SELECT id, kind, message, actions, reason, status,
                      COALESCE(created_ts_s, 0) as ts_sort,
                      created_ts
               FROM nudges
               ORDER BY ts_sort DESC, id DESC
               LIMIT ? OFFSET ?""",
            (limit, offset),
        )

        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "kind": row[1],
                "message": row[2],
                "actions": json.loads(row[3]) if row[3] else [],
                "reason": row[4],
                "status": row[5],
                "created_ts": row[7],  # legacy ISO column
                "created_ts_s": row[6] if row[6] else None,
            }
            items.append(item)

        return items


@router.get("/reflections")
def get_reflections(limit: int = 50, offset: int = 0) -> list[dict[str, Any]]:
    """
    Get recent reflections from scheduler.

    Returns list of reflections generated by drives.
    """
    if limit < 1 or limit > 100:
        raise HTTPException(400, "limit must be between 1 and 100")
    if offset < 0:
        raise HTTPException(400, "offset must be non-negative")

    with db_ctx.wal_db(DB_PATH, timeout=30.0) as conn:
        conn.execute("PRAGMA busy_timeout = 5000")

        # Get results, prefer ts_s if available
        cur = conn.execute(
            """SELECT id, kind, content, meta, pinned,
                      COALESCE(ts_s, 0) as ts_sort,
                      ts
               FROM reflections
               ORDER BY ts_sort DESC, id DESC
               LIMIT ? OFFSET ?""",
            (limit, offset),
        )

        items = []
        for row in cur.fetchall():
            item = {
                "id": row[0],
                "kind": row[1],
                "content": row[2],
                "meta": json.loads(row[3]) if row[3] else None,
                "pinned": bool(row[4]),
                "ts": row[6],  # legacy ISO column
                "ts_s": row[5] if row[5] else None,
            }
            items.append(item)

        return items
